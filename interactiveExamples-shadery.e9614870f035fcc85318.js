(()=>{"use strict";var n,e={4391:(n,e,o)=>{var r=o(9477);const t=document.createElement("canvas");t.classList.add("webgl-canvas");const i=new r.CP7({canvas:t});i.setPixelRatio(window.devicePixelRatio);const a=i,s=new class{constructor(){this.initialized=!1,this._activeExample=null,this._clock=new r.SUY(!1),this._tick=this._tick.bind(this),window.addEventListener("resize",this._resize.bind(this))}init(){a.setAnimationLoop(this._tick),this.initialized=!0}playExample(n){this.initialized&&(n.playButton.style.display="none",n.resetButton.style.display="flex",this.resetExample(),this._clock.start(),n.canvasContainer.appendChild(t),this._activeExample=n,this._resize(),n.initialized||(n.initialized=!0,n.onInit?.()),n.onPlay?.())}resetExample(){this._activeExample&&(this._clock.stop(),this._activeExample.playButton.style.display="flex",this._activeExample.resetButton.style.display="none",this._activeExample.canvasContainer.removeChild(t),this._activeExample.onReset?.(),this._activeExample=null)}_tick(){if(this._activeExample){const n=this._clock.getDelta(),e=this._clock.getElapsedTime();this._activeExample.onTick?.(n,e)}}_resize(){this._activeExample&&(this._activeExample.camera&&(this._activeExample.camera.aspect=this._activeExample.canvasContainer.clientWidth/this._activeExample.canvasContainer.clientHeight,this._activeExample.camera.updateProjectionMatrix()),a.setSize(this._activeExample.canvasContainer.clientWidth,this._activeExample.canvasContainer.clientHeight),a.setPixelRatio(Math.min(window.devicePixelRatio,2)),this._activeExample.onResize?.(this._activeExample.canvasContainer.clientWidth,this._activeExample.canvasContainer.clientHeight))}},l=class{constructor(n,e){this.initialized=!1,this.camera=e;const o=document.querySelector(`[data-example-id="${n}"]`);if(!o)throw new Error("Example element wasn't found");o.classList.add("interactive-example");const r=document.createElement("div");r.classList.add("interactive-example__header"),o.appendChild(r);const t=document.createElement("div");t.classList.add("interactive-example__icon"),t.innerHTML='\n            <svg>\n                <use xlink:href="../../static/img/icon-sprite.svg#icon-embed2"></use>\n            </svg>\n        ',r.appendChild(t);const i=document.createElement("button");i.classList.add("interactive-example__button"),i.innerHTML='\n            <svg>\n                <use xlink:href="../../static/img/icon-sprite.svg#icon-play"></use>\n            </svg>\n            <span>Spustit</span>\n        ',r.appendChild(i);const a=document.createElement("button");a.classList.add("interactive-example__button"),a.innerHTML='\n            <svg>\n                <use xlink:href="../../static/img/icon-sprite.svg#icon-spinner11"></use>\n            </svg>\n            <span>Resetovat</span>\n        ',a.style.display="none",r.appendChild(a);const l=document.createElement("div");l.classList.add("interactive-example__canvas-container"),o.appendChild(l),i.addEventListener("click",(()=>s.playExample(this))),a.addEventListener("click",(()=>s.resetExample())),this.playButton=i,this.resetButton=a,this.canvasContainer=l}get renderer(){return a}get canvas(){return t}};var v=o(9365);let d;const c=new r.cPb(45,1,.1,1e3);let m;const u=new l(1,c);let p;u.onInit=()=>{d=new r.xsS,c.position.z=3,d.add(c);const n=new r.FIo({vertexShader:"\n        uniform mat4 projectionMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n\n        attribute vec3 position;\n\n        void main() {\n            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n        }\n        ",fragmentShader:"\n        precision mediump float;\n\n        void main() {\n            gl_FragColor = vec4(0, 1, 0, 1);\n        }\n        "}),e=new r.Kj0(new r.DvJ(1,1,1),n);d.add(e)},u.onPlay=()=>{c.rotation.set(0,0,0),m=new v.z(c,u.canvasContainer),m.enableDamping=!0},u.onReset=()=>{m&&(m.reset(),m.dispose(),m=null)},u.onTick=()=>{m.update(),u.renderer.render(d,c)};const x=new r.cPb(45,1,.1,1e3);let w;const g=new l(2,x);let f;g.onInit=()=>{p=new r.xsS,x.position.z=3,p.add(x);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvoid main() {\r\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\r\n}",fragmentShader:"precision mediump float;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(0, 1, 0, 1);\r\n}"}),e=new r.Kj0(new r.DvJ(1,1,1),n);p.add(e)},g.onPlay=()=>{x.rotation.set(0,0,0),w=new v.z(x,g.canvasContainer),w.enableDamping=!0},g.onReset=()=>{w&&(w.reset(),w.dispose(),w=null)},g.onTick=()=>{w.update(),g.renderer.render(p,x)};const P=new r.cPb(45,1,.1,1e3);let h;const y=new l(3,P);let b;y.onInit=()=>{f=new r.xsS,P.position.z=3,f.add(P);const n=new r.FIo({vertexShader:"// matice, které můžeme použít k transformaci vertexu\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\n// atribut obsahující pozici vertexu\r\nattribute vec3 position;\r\n\r\n// funkce main se spouští pro každý vertex geometrie\r\nvoid main() {\r\n    // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\r\n\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // posunutí vertexu směrem nahoru\r\n    modelPosition.y += 1.0;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(0, 1, 0, 1);\r\n}"}),e=new r.Kj0(new r.DvJ(1,1,1),n);f.add(e)},y.onPlay=()=>{P.rotation.set(0,0,0),h=new v.z(P,y.canvasContainer),h.enableDamping=!0},y.onReset=()=>{h&&(h.reset(),h.dispose(),h=null)},y.onTick=()=>{h.update(),y.renderer.render(f,P)};const M=new r.cPb(45,1,.1,1e3);let _;const z=new l(4,M);let j;z.onInit=()=>{b=new r.xsS,M.position.z=3,b.add(M);const n=new r.FIo({vertexShader:"// matice, které můžeme použít k transformaci vertexu\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\n// atribut obsahující pozici vertexu\r\nattribute vec3 position;\r\n\r\nattribute float aRandom;\r\n\r\nvoid main() {\r\n    // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\r\n\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // posunutí vertexu směrem nahoru\r\n    modelPosition.y += 1.0;\r\n    // změnění pozice vertexu na ose X a Z\r\n    modelPosition.xz += aRandom;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(0, 1, 0, 1);\r\n}"}),e=new r.Kj0(new r.DvJ(1,1,1),n);b.add(e);const o=new Float32Array(e.geometry.attributes.position.count);for(let n=0;n<o.length;n++)o[n]=.2*Math.random();const t=new r.TlE(o,1);e.geometry.setAttribute("aRandom",t)},z.onPlay=()=>{M.rotation.set(0,0,0),_=new v.z(M,z.canvasContainer),_.enableDamping=!0},z.onReset=()=>{_&&(_.reset(),_.dispose(),_=null)},z.onTick=()=>{_.update(),z.renderer.render(b,M)};const k=new r.cPb(45,1,.1,1e3);let C;const S=new l(5,k);let F;S.onInit=()=>{j=new r.xsS,k.position.z=3,j.add(k);const n=new r.FIo({vertexShader:"// matice, které můžeme použít k transformaci vertexu\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\n// atribut obsahující pozici vertexu\r\nattribute vec3 position;\r\n\r\nattribute float aRandom;\r\n\r\nvoid main() {\r\n    // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\r\n\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // posunutí vertexu směrem nahoru\r\n    modelPosition.y += 1.0;\r\n    // změnění pozice vertexu na ose X a Z\r\n    modelPosition.xz += aRandom;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"// nastavení preciznosti datového typu float\r\nprecision mediump float;\r\n\r\n// tato funkce se spouští pro každý fragment\r\nvoid main() {\r\n    // nastavení barvy fragmentu na červenou\r\n    // barvu s poloviční průhledností\r\n    gl_FragColor = vec4(1, 0, 0, 0.5);\r\n}",transparent:!0}),e=new r.Kj0(new r.DvJ(1,1,1),n);j.add(e);const o=new Float32Array(e.geometry.attributes.position.count);for(let n=0;n<o.length;n++)o[n]=.2*Math.random();const t=new r.TlE(o,1);e.geometry.setAttribute("aRandom",t)},S.onPlay=()=>{k.rotation.set(0,0,0),C=new v.z(k,S.canvasContainer),C.enableDamping=!0},S.onReset=()=>{C&&(C.reset(),C.dispose(),C=null)},S.onTick=()=>{C.update(),S.renderer.render(j,k)};const E=new r.cPb(45,1,.1,1e3);let T;const D=new l(6,E);let R;D.onInit=()=>{F=new r.xsS,E.position.z=3,F.add(E);const n=new r.FIo({vertexShader:"// matice, které můžeme použít k transformaci vertexu\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\n// atribut obsahující pozici vertexu\r\nattribute vec3 position;\r\n\r\nattribute float aRandom;\r\n\r\nvoid main() {\r\n    // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\r\n\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // posunutí vertexu směrem nahoru\r\n    modelPosition.y += 1.0;\r\n    // změnění pozice vertexu na ose X a Z\r\n    modelPosition.xz += aRandom;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"// nastavení preciznosti datového typu float\r\nprecision mediump float;\r\n\r\n// tato funkce se spouští pro každý fragment\r\nvoid main() {\r\n    // nastavení barvy fragmentu na červenou\r\n    // barvu s poloviční průhledností\r\n    gl_FragColor = vec4(1, 0, 0, 0.5);\r\n}",transparent:!0,wireframe:!0}),e=new r.Kj0(new r._12(1,1,32,32),n);F.add(e)},D.onPlay=()=>{E.rotation.set(0,0,0),T=new v.z(E,D.canvasContainer),T.enableDamping=!0},D.onReset=()=>{T&&(T.reset(),T.dispose(),T=null)},D.onTick=()=>{T.update(),D.renderer.render(F,E)};const I=new r.cPb(45,1,.1,1e3);let U;const V=new l(7,I);let K;V.onInit=()=>{R=new r.xsS,I.position.z=3,R.add(I);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(1, 1, 1, 1);\r\n}",transparent:!0}),e=new r.Kj0(new r._12(1,1,32,32),n);R.add(e)},V.onPlay=()=>{I.rotation.set(0,0,0),U=new v.z(I,V.canvasContainer),U.enableDamping=!0},V.onReset=()=>{U&&(U.reset(),U.dispose(),U=null)},V.onTick=()=>{U.update(),V.renderer.render(R,I)};const L=new r.cPb(45,1,.1,1e3);let X;const q=new l(8,L);let Y;q.onInit=()=>{K=new r.xsS,L.position.z=3,K.add(L);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // získání hodnoty podle pozice vertexu na ose X a Y\r\n    // - používáme dvě volání funkce sin (pro pozici na ose X a Y), které spolu vynásobíme\r\n    // - nemusíte moc zkoumat jak to funguje, prostě získáváme nějakou hodnotu podle pozice\r\n    //   vertexu na ose X a Y\r\n    float value = abs(sin(modelPosition.x * 12.0) * sin(modelPosition.y * 12.0));\r\n    // nastavení získané hodnoty pro pozici na ose Z\r\n    modelPosition.z = value;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(1, 1, 1, 1);\r\n}",transparent:!0}),e=new r.Kj0(new r._12(1,1,32,32),n);K.add(e)},q.onPlay=()=>{L.rotation.set(0,0,0),X=new v.z(L,q.canvasContainer),X.enableDamping=!0},q.onReset=()=>{X&&(X.reset(),X.dispose(),X=null)},q.onTick=()=>{X.update(),q.renderer.render(K,L)};const J=new r.cPb(45,1,.1,1e3);let O;const Z=new l(9,J);let B;Z.onInit=()=>{Y=new r.xsS,J.position.z=3,Y.add(J);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\n// vytvoření varying\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // získání hodnoty podle pozice vertexu na ose X a Y\r\n    float value = abs(sin(modelPosition.x * 12.0) * sin(modelPosition.y * 12.0));\r\n    // nastavení získané hodnoty pro pozici na ose Z\r\n    modelPosition.z = value;\r\n\r\n    // uložení získané hodnoty do varying\r\n    vValue = value;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\n// nadeklarování varyingu\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    // hodnotu varyingu používáme pro modrý kanál barvy\r\n    gl_FragColor = vec4(0, 0, vValue, 1);\r\n}",transparent:!0}),e=new r.Kj0(new r._12(1,1,32,32),n);Y.add(e)},Z.onPlay=()=>{J.rotation.set(0,0,0),O=new v.z(J,Z.canvasContainer),O.enableDamping=!0},Z.onReset=()=>{O&&(O.reset(),O.dispose(),O=null)},Z.onTick=()=>{O.update(),Z.renderer.render(Y,J)};const H=new r.cPb(45,1,.1,1e3);let A;const W=new l(10,H);let $;W.onInit=()=>{B=new r.xsS,H.position.z=3,B.add(H);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\n// vytvoření varying\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // získání hodnoty podle pozice vertexu na ose X a Y\r\n    float value = abs(sin(modelPosition.x * 12.0) * sin(modelPosition.y * 12.0));\r\n    // // nastavení získané hodnoty pro pozici na ose Z\r\n    // modelPosition.z = value;\r\n\r\n    // uložení získané hodnoty do varying\r\n    vValue = value;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\n// nadeklarování varyingu\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    // hodnotu varyingu používáme pro modrý kanál barvy\r\n    gl_FragColor = vec4(0, 0, vValue, 1);\r\n}",transparent:!0}),e=new r.Kj0(new r._12(1,1,32,32),n);B.add(e)},W.onPlay=()=>{H.rotation.set(0,0,0),A=new v.z(H,W.canvasContainer),A.enableDamping=!0},W.onReset=()=>{A&&(A.reset(),A.dispose(),A=null)},W.onTick=()=>{A.update(),W.renderer.render(B,H)};const G=new r.cPb(45,1,.1,1e3);let N;const Q=new l(11,G);let nn;Q.onInit=()=>{$=new r.xsS,G.position.z=3,$.add(G);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvarying float vValue;\r\n\r\n// deklarování uniform\r\nuniform float uFrequency;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // získání hodnoty podle pozice vertexu na ose X a Y\r\n    float value = abs(sin(modelPosition.x * uFrequency) * sin(modelPosition.y * uFrequency));\r\n    // nastavení získané hodnoty pro pozici na ose Z\r\n    modelPosition.z = value;\r\n\r\n    // uložení získané hodnoty do varying\r\n    vValue = value;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\n// nadeklarování varyingu\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    // hodnotu varyingu používáme pro modrý kanál barvy\r\n    gl_FragColor = vec4(0, 0, vValue, 1);\r\n}",transparent:!0,uniforms:{uFrequency:{value:12}}}),e=new r.Kj0(new r._12(1,1,32,32),n);$.add(e)},Q.onPlay=()=>{G.rotation.set(0,0,0),N=new v.z(G,Q.canvasContainer),N.enableDamping=!0},Q.onReset=()=>{N&&(N.reset(),N.dispose(),N=null)},Q.onTick=()=>{N.update(),Q.renderer.render($,G)};const en=new r.cPb(45,1,.1,1e3);let on;const rn=new l(12,en);let tn;rn.onInit=()=>{nn=new r.xsS,en.position.z=3,nn.add(en);const n=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvarying float vValue;\r\n\r\n// deklarování uniform\r\nuniform float uFrequency;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // získání hodnoty podle pozice vertexu na ose X a Y\r\n    float value = abs(sin(modelPosition.x * uFrequency) * sin(modelPosition.y * uFrequency));\r\n    // nastavení získané hodnoty pro pozici na ose Z\r\n    modelPosition.z = value;\r\n\r\n    // uložení získané hodnoty do varying\r\n    vValue = value;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\n// nadeklarování varyingu\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    // hodnotu varyingu používáme pro modrý kanál barvy\r\n    gl_FragColor = vec4(0, 0, vValue, 1);\r\n}",transparent:!0,uniforms:{uFrequency:{value:24}}}),e=new r.Kj0(new r._12(1,1,32,32),n);nn.add(e)},rn.onPlay=()=>{en.rotation.set(0,0,0),on=new v.z(en,rn.canvasContainer),on.enableDamping=!0},rn.onReset=()=>{on&&(on.reset(),on.dispose(),on=null)},rn.onTick=()=>{on.update(),rn.renderer.render(nn,en)};const an=new r.cPb(45,1,.1,1e3);let sn,ln;const vn=new l(13,an);let dn;vn.onInit=()=>{tn=new r.xsS,an.position.z=3,tn.add(an),ln=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvarying float vValue;\r\n\r\n// deklarování uniform\r\nuniform float uFrequency;\r\n\r\n// uniform pro uběhnutý čas\r\nuniform float uElapsedTime;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n\r\n    // získání hodnoty podle pozice vertexu na ose X a Y\r\n    float value = abs(sin(modelPosition.x * uFrequency + uElapsedTime) * sin(modelPosition.y * uFrequency + uElapsedTime));\r\n    // nastavení získané hodnoty pro pozici na ose Z\r\n    modelPosition.z = value;\r\n\r\n    // uložení získané hodnoty do varying\r\n    vValue = value;\r\n\r\n\tvec4 viewPosition = viewMatrix * modelPosition;\r\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n}",fragmentShader:"precision mediump float;\r\n\r\n// nadeklarování varyingu\r\nvarying float vValue;\r\n\r\nvoid main() {\r\n    // hodnotu varyingu používáme pro modrý kanál barvy\r\n    gl_FragColor = vec4(0, 0, vValue, 1);\r\n}",transparent:!0,uniforms:{uFrequency:{value:24},uElapsedTime:{value:0}}});const n=new r.Kj0(new r._12(1,1,32,32),ln);tn.add(n)},vn.onPlay=()=>{an.rotation.set(0,0,0),sn=new v.z(an,vn.canvasContainer),sn.enableDamping=!0},vn.onReset=()=>{sn&&(sn.reset(),sn.dispose(),sn=null)},vn.onTick=(n,e)=>{sn.update(),ln.uniforms.uElapsedTime.value=e,vn.renderer.render(tn,an)};const cn=new r.cPb(45,1,.1,1e3);let mn;const un=new l(14,cn);let pn;un.onInit=()=>{dn=new r.xsS,cn.position.z=3,dn.add(cn);const n=(new r.dpR).load("../../static/img/textures/bricks/brick_wall_001_diffuse_1k.jpg"),e=new r.FIo({vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nattribute vec3 position;\r\n\r\n// attribute pro UV souřadnice\r\nattribute vec2 uv;\r\n\r\n// deklarace varying pro předání UV souřadnic do fragment shaderu\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n\r\n    // předání UV souřadnic do fragment shaderu pomocí varying\r\n    vUv = uv;\r\n}",fragmentShader:"precision mediump float;\r\n\r\n// uniform pro texturu\r\nuniform sampler2D uTexture;\r\n\r\n// UV souřadnice\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    // použití barvy z textury pro fragment podle UV souřadnic\r\n    gl_FragColor = texture2D(uTexture, vUv);\r\n}",uniforms:{uTexture:{value:n}}}),o=new r.Kj0(new r.DvJ(1,1,1),e);dn.add(o)},un.onPlay=()=>{cn.rotation.set(0,0,0),mn=new v.z(cn,un.canvasContainer),mn.enableDamping=!0},un.onReset=()=>{mn&&(mn.reset(),mn.dispose(),mn=null)},un.onTick=()=>{mn.update(),un.renderer.render(dn,cn)};const xn=new r.cPb(45,1,.1,1e3);let wn;const gn=new l(15,xn);let fn;gn.onInit=()=>{pn=new r.xsS,xn.position.z=3,pn.add(xn);const n=(new r.dpR).load("../../static/img/textures/bricks/brick_wall_001_diffuse_1k.jpg"),e=new r.jyz({vertexShader:"varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n\r\n    vUv = uv;\r\n}",fragmentShader:"uniform sampler2D uTexture;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(uTexture, vUv);\r\n}",uniforms:{uTexture:{value:n}}}),o=new r.Kj0(new r.DvJ(1,1,1),e);pn.add(o)},gn.onPlay=()=>{xn.rotation.set(0,0,0),wn=new v.z(xn,gn.canvasContainer),wn.enableDamping=!0},gn.onReset=()=>{wn&&(wn.reset(),wn.dispose(),wn=null)},gn.onTick=()=>{wn.update(),gn.renderer.render(pn,xn)};const Pn=new r.cPb(45,1,.1,1e3);let hn;const yn=new l(16,Pn);let bn;yn.onInit=()=>{fn=new r.xsS,Pn.position.z=3,fn.add(Pn);const n=(new r.dpR).load("../../static/img/textures/bricks/brick_wall_001_diffuse_1k.jpg"),e=new r.jyz({vertexShader:"varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n\r\n    vUv = uv;\r\n}",fragmentShader:"// uniform pro texturu\r\nuniform sampler2D uTexture;\r\n\r\n// UV souřadnice\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    // // použití barvy z textury pro fragment podle UV souřadnic\r\n    // gl_FragColor = texture2D(uTexture, vUv);\r\n\r\n    float strength = mod(vUv.y * 10.0, 1.0);\r\n    gl_FragColor = vec4(vec3(strength), 1.0);\r\n}",uniforms:{uTexture:{value:n}}}),o=new r.Kj0(new r.DvJ(1,1,1),e);fn.add(o)},yn.onPlay=()=>{Pn.rotation.set(0,0,0),hn=new v.z(Pn,yn.canvasContainer),hn.enableDamping=!0},yn.onReset=()=>{hn&&(hn.reset(),hn.dispose(),hn=null)},yn.onTick=()=>{hn.update(),yn.renderer.render(fn,Pn)};const Mn=new r.cPb(45,1,.1,1e3);let _n;const zn=new l(17,Mn);let jn;zn.onInit=()=>{bn=new r.xsS,Mn.position.z=3,bn.add(Mn);const n=(new r.dpR).load("../../static/img/textures/bricks/brick_wall_001_diffuse_1k.jpg"),e=new r.jyz({vertexShader:"varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n\r\n    gl_Position = projectedPosition;\r\n\r\n    vUv = uv;\r\n}",fragmentShader:"// uniform pro texturu\r\nuniform sampler2D uTexture;\r\n\r\n// UV souřadnice\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    // // použití barvy z textury pro fragment podle UV souřadnic\r\n    // gl_FragColor = texture2D(uTexture, vUv);\r\n\r\n    // float strength = mod(vUv.y * 10.0, 1.0);\r\n    // gl_FragColor = vec4(vec3(strength), 1.0);\r\n\r\n    float barX = step(0.4, mod(vUv.x * 10.0, 1.0));\r\n    barX *= step(0.8, mod(vUv.y * 10.0, 1.0));\r\n    float barY = step(0.4, mod(vUv.y * 10.0, 1.0));\r\n    barY *= step(0.8, mod(vUv.x * 10.0, 1.0));\r\n    float strength = barX + barY;\r\n    gl_FragColor = vec4(vec3(strength), 1.0);\r\n}",uniforms:{uTexture:{value:n}}}),o=new r.Kj0(new r.DvJ(1,1,1),e);bn.add(o)},zn.onPlay=()=>{Mn.rotation.set(0,0,0),_n=new v.z(Mn,zn.canvasContainer),_n.enableDamping=!0},zn.onReset=()=>{_n&&(_n.reset(),_n.dispose(),_n=null)},zn.onTick=()=>{_n.update(),zn.renderer.render(bn,Mn)};const kn=new r.cPb(45,1,.1,1e3);let Cn;const Sn=new l(18,kn);Sn.onInit=()=>{jn=new r.xsS,kn.position.z=3,jn.add(kn);const n=new r.vBJ({color:16711680});n.onBeforeCompile=n=>{n.fragmentShader=n.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n            vec4 diffuseColor = vec4(0, 1, 0, opacity);\n            ")};const e=new r.Kj0(new r.DvJ(1,1,1),n);jn.add(e)},Sn.onPlay=()=>{kn.rotation.set(0,0,0),Cn=new v.z(kn,Sn.canvasContainer),Cn.enableDamping=!0},Sn.onReset=()=>{Cn&&(Cn.reset(),Cn.dispose(),Cn=null)},Sn.onTick=()=>{Cn.update(),Sn.renderer.render(jn,kn)},s.init()}},o={};function r(n){var t=o[n];if(void 0!==t)return t.exports;var i=o[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.m=e,n=[],r.O=(e,o,t,i)=>{if(!o){var a=1/0;for(d=0;d<n.length;d++){for(var[o,t,i]=n[d],s=!0,l=0;l<o.length;l++)(!1&i||a>=i)&&Object.keys(r.O).every((n=>r.O[n](o[l])))?o.splice(l--,1):(s=!1,i<a&&(a=i));if(s){n.splice(d--,1);var v=t();void 0!==v&&(e=v)}}return e}i=i||0;for(var d=n.length;d>0&&n[d-1][2]>i;d--)n[d]=n[d-1];n[d]=[o,t,i]},r.d=(n,e)=>{for(var o in e)r.o(e,o)&&!r.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})},r.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),(()=>{var n={9680:0};r.O.j=e=>0===n[e];var e=(e,o)=>{var t,i,[a,s,l]=o,v=0;if(a.some((e=>0!==n[e]))){for(t in s)r.o(s,t)&&(r.m[t]=s[t]);if(l)var d=l(r)}for(e&&e(o);v<a.length;v++)i=a[v],r.o(n,i)&&n[i]&&n[i][0](),n[i]=0;return r.O(d)},o=self.webpackChunkthreejs_navod=self.webpackChunkthreejs_navod||[];o.forEach(e.bind(null,0)),o.push=e.bind(null,o.push.bind(o))})();var t=r.O(void 0,[9365,7017],(()=>r(4391)));t=r.O(t)})();